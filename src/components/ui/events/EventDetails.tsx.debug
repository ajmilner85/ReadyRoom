// Copy the entire file here and then add the debugging code
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { Card } from '../card';
import { Check, Send, RefreshCw, ImageIcon, X, Upload } from 'lucide-react';
import type { Event } from '../../../types/EventTypes';
import { publishEventToDiscord } from '../../../utils/discordService';
import { fetchEvents } from '../../../utils/supabaseClient';
import { uploadEventImage, deleteEventImage } from '../../../utils/eventImageService';

/**
 * Check if the server is available before attempting to publish
 * @returns A promise that resolves to a boolean indicating if the server is available
 */
async function checkServerAvailability(): Promise<boolean> {
  try {
    // Use a simple HEAD request to check if the server is responding
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 3000);
    
    const response = await fetch('http://localhost:3001/api/health', {
      method: 'HEAD',
      signal: controller.signal
    });
    
    clearTimeout(timeoutId);
    return response.ok;
  } catch (error) {
    return false;
  }
}

interface EventDetailsProps {
  event: Event | null;
}

const EventDetails: React.FC<EventDetailsProps> = ({ event }) => {
  const [publishing, setPublishing] = useState(false);
  const [refreshing, setRefreshing] = useState(false);
  const [publishMessage, setPublishMessage] = useState<{type: 'success' | 'error', text: string} | null>(null);
  const [imageLoading, setImageLoading] = useState(false);
  const [imageError, setImageError] = useState<string | null>(null);
  const [imagePreview, setImagePreview] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  
  // Set initial image preview from event data with improved debugging
  useEffect(() => {
    // Add debugging to understand the image URL handling
    const eventObj = event as any; // Use any to inspect all properties without TypeScript errors
    
    console.log('[DEBUG] Event details for image handling:', {
      eventId: event?.id,
      imageUrl: event?.imageUrl,
      image_url: eventObj?.image_url, // Check for snake_case property from DB
      entireEvent: eventObj
    });

    // First check for standard property name
    if (event?.imageUrl) {
      console.log('[DEBUG] Using event.imageUrl for preview:', event.imageUrl);
      setImagePreview(event.imageUrl);
    } 
    // Then fall back to snake_case property name from DB
    else if (eventObj?.image_url) {
      console.log('[DEBUG] Using event.image_url for preview:', eventObj.image_url);
      setImagePreview(eventObj.image_url);
    } 
    // No image URL found
    else {
      console.log('[DEBUG] No image URL found in event object');
      setImagePreview(null);
    }
  }, [event]);

  // Handle image upload
  const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    if (!event || !e.target.files || e.target.files.length === 0) return;
    
    const file = e.target.files[0];
    
    // Validate file type
    if (!file.type.startsWith('image/')) {
      setImageError('Please select an image file');
      return;
    }
    
    // Validate file size (max 5MB)
    if (file.size > 5 * 1024 * 1024) {
      setImageError('Image size should be less than 5MB');
      return;
    }
    
    setImageLoading(true);
    setImageError(null);
    
    try {
      // Create object URL for preview
      const previewUrl = URL.createObjectURL(file);
      setImagePreview(previewUrl);
      
      // Upload to Supabase
      const { url, error } = await uploadEventImage(event.id, file);
      
      if (error) {
        throw new Error(error.message);
      }
      
      // Update local state with the Supabase URL
      if (url) {
        console.log('[DEBUG] Image upload successful, new URL:', url);
        setImagePreview(url);
        // Release the object URL since we now have the Supabase URL
        URL.revokeObjectURL(previewUrl);
      }
    } catch (error) {
      console.error('[DEBUG] Error uploading image:', error);
      setImageError(error instanceof Error ? error.message : 'Failed to upload image');
      setImagePreview(null);
    } finally {
      setImageLoading(false);
      // Reset the file input
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };
  
  // Handle image removal with improved debugging
  const handleRemoveImage = async () => {
    // Access image URL from either property
    const eventObj = event as any;
    const imageUrl = event?.imageUrl || eventObj?.image_url;
    
    console.log('[DEBUG] Attempting to remove image with URL:', imageUrl);
    
    if (!event || !imageUrl) {
      console.log('[DEBUG] No image URL found to remove');
      return;
    }
    
    setImageLoading(true);
    
    try {
      const { error } = await deleteEventImage(imageUrl);
      
      if (error) {
        throw new Error(error.message);
      }
      
      console.log('[DEBUG] Image successfully removed');
      setImagePreview(null);
    } catch (error) {
      console.error('[DEBUG] Error removing image:', error);
      setImageError(error instanceof Error ? error.message : 'Failed to remove image');
    } finally {
      setImageLoading(false);
    }
  };
  
  // Function to trigger file input click
  const triggerFileInput = () => {
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
  };

  // Function to refresh event data from database with debugging
  const refreshEventData = useCallback(async () => {
    if (!event) return;
    
    try {
      setRefreshing(true);
      console.log('[DEBUG] Refreshing event data for ID:', event.id);
      
      // Get latest event data from database
      const { events: fetchedEvents } = await fetchEvents(event.cycleId);
      
      // Find this event in the results
      const updatedEvent = fetchedEvents.find(e => e.id === event.id);
      
      if (updatedEvent) {
        console.log('[DEBUG] Refreshed event data:', updatedEvent);
        
        // Check for image URL in the refreshed event
        const updatedEventObj = updatedEvent as any;
        const refreshedImageUrl = updatedEvent.imageUrl || updatedEventObj.image_url;
        
        if (refreshedImageUrl) {
          console.log('[DEBUG] Found image URL in refreshed event:', refreshedImageUrl);
          setImagePreview(refreshedImageUrl);
        }
        
        // Manually trigger a re-render by updating the DOM
        // This allows parent component to handle the actual event state
        const discordCard = document.querySelector('#discord-integration-card');
        if (discordCard) {
          if (updatedEvent.discordEventId || updatedEvent.discordMessageId) {
            discordCard.classList.remove('hidden');
          } else {
            discordCard.classList.add('hidden');
          }
        }
        
        // Update button state
        const publishBtn = document.querySelector('#publish-discord-btn');
        if (publishBtn && (updatedEvent.discordEventId || updatedEvent.discordMessageId)) {
          publishBtn.setAttribute('disabled', 'true');
          publishBtn.classList.add('published');
          const btnSpan = publishBtn.querySelector('span');
          if (btnSpan) {
            btnSpan.textContent = 'Published to Discord';
          }
        }
      } else {
        console.log('[DEBUG] Event not found in refreshed data');
      }
    } catch (error) {
      console.error('[DEBUG] Error refreshing event data:', error);
      // Silent failure for refresh operations
    } finally {
      setRefreshing(false);
    }
  }, [event]);

  // Rest of component code remains unchanged
